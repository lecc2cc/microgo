### 过载保护和限流



#### 过载保护

**令牌桶算法**

是一个存放固定容量令牌的桶，按照固定速率忘桶里添加令牌。令牌桶算法的描述如下：

+ 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。
+ 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。
+ 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。
+ 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等等）。

![image](https://github.com/lecc2cc/microgo/blob/master/images/05-03-rate-limit-2021-06-02-23.png?raw=true)



实现[rate]( https://pkg.go.dev/golang.org/x/time/rate)。

令牌桶算法比较简单，但是阈值设定需要依据机器、业务实现等条件判断，不能很好判断服务的能力。

**漏桶算法**

作为计量工具(The Leaky Bucket Algorithm as a Meter)，可以用于流量调整(Traffic Shaping)和流量控制(Traffic Policing)，漏桶算法的描述如下：

+ 一个固定容量的漏桶，按照常量固定速率流出水滴。
+ 如果桶是空的，则不需要流出水滴。
+ 可以以任意速率流入水滴到漏桶。
+ 如果流入水滴超出了桶的容量，则流入的水滴溢出了(被丢弃)，则漏桶容量是不变的。

![image](https://github.com/lecc2cc/microgo/blob/master/images/05-03-leaky-rate-2021-06-02-23.png?raw=true)

uber实现[地址](https://github.com/uber-go/ratelimit)

漏桶/令牌桶确实能够保护系统不被拖垮，但不管漏桶还是令牌桶，其保护思路是设定一个指标，当超过该指标后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。但其通常都是被动的，其实际效果取决于限流阈值设置是否合理，但往往设置合理不是一件容易的事情。

+ 集群增加机器或者减少机器限流阈值是否要重新设置？
+ 设置限流阈值的依据是什么？
+ 人力运维成本是否过高？
+ 当调用方反馈429时，这个时候重新设置限流，其实流量高峰已经过了重新评估限流是否有意义？

总体来说漏桶/令牌桶的缺点是太被动，不能快速适应流量变化。

因此需要一种自适应的限流算法，即过载保护，根据系统当前的负载自动丢弃流量。



