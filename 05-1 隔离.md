### 微服务可用性设计

+ 隔离
+ 超时控制
+ 过载保护
+ 限流
+ 降级
+ 重试
+ 负载均衡
+ 最佳实践



### 隔离

隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。

1. **服务隔离**
   + 动静分离、读写分离
2. **轻重隔离**
   + 核心、热点、快慢
3. **物理隔离**
   + 线程、进程、集群、机房



#### 服务隔离

+ 动静隔离

  本质上是加速/缓存访问变换频次小的。例如，CPU的`cacheline` false sharing；数据库mysql表设计中避免buffpool频繁过期；隔离动静表；架构中的图片、静态资源等缓存加速。

  

  在CDN场景中，将静态资源和动态API分离，也是体现了隔离的思路。

  - 降低应用服务器负载，静态文件访问负载全部通过CDN。
  - 静态CDN宽带加速，延迟低。
  - 对象存储存储费用低。
  - 海量存储空间，无需考虑存储架构升级。

  在数据库场景中，MySQL BufferPool是用于缓存DataPage的，DataPage可以理解为缓存了表的行。那么如果频繁更新数据表，导致DataPage不断置换，从而导致命中率下降的问题。

  在表设计中，可以沿用类似的思路，其主表很少更新，而旁路表或统计表需要高频更新。此时可以对主表和旁路表进行分离分库，从而使得主表合理利用DataPage的缓存。而高频更新的数据可以订阅某些事件的数据(例如`binlog`)实现对数据的更新。

+ 读写分离：主从、`ReplicaSet`、`CQRS`(Command Query Responsibility Segregation, 命令查询的责任分离)。

#### 轻重隔离

+ 核心隔离

  业务按照Level进行资源池划分(L0/L1/Le)。

  - 核心/非核心的故障域的差异隔离(机器资源是否独占、依赖资源)。
  - 多集群，通过冗余资源来提升吞吐和容灾能力。

+ 快慢隔离

  服务的吞吐想象为一个池子，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增加，对小请求产生影响。

  

  例如，在日志传输体系的架构设计中，整个事件上报的数据流都投放到一个kafka topic，流内再区分不同的logid。logid会有不同的sink端（下沉端，落库），它们之间会出现差速，比如HDFS抖动吞吐下降，但ES正常水位，这样导致全局数据消费数据速度变慢。此时需要按各种维度隔离：sink端、部门、业务、logid、重要性(S/A/B/C)等等。

  

+ 热点隔离

  热点即经常访问的数据。很多时候希望统计某个热点数据中访问频次最高的Top K数据，并对其访问进行缓存。

  

  **小表广播**: 对于一些不是经常变化，但有时很高频访问的数据。可以从remote cache 提升为 local cache，app定时更新，甚至可以让运营后台支持广播刷新local cache。（在Go语言中，atomic.Value可以原子性替换值，从而避免数据更新时导致脏数据）

  **主动预热**：比如直播房间页高在线情况下。1. 监控主动防御（旁路服务监控），当监控服务发现在线人数超过阈值时，广播给房间服务的server，让房间服务主动将remote cache提升为local cache。2. 使用进程级别自我发现热点，在一个进程内的资源访问频次的多少做滑动窗口让进程主动去预热，提升缓存为local cache。

#### 物理隔离

+ 线程隔离

  主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会将故障扩散和影响其他线程池，保证服务可用。

  

  对于Go而言，所有IO都是Nonblocking，且托管给了Runtime，只会阻塞Goroutine，不阻塞M。只需要考虑Goroutine总量的控制，不需要线程模型语言的线程隔离。

  

  像Java中，用户请求到Tomcat，Tomcat在本身的线程池中执行业务逻辑，例如请求用户服务、推荐服务和积分服务。假设在请求推荐服务耗时高比较高时，将消耗大量Tomcat线程，严重导致整个Tomcat不能提供服务。此时需要将各个服务隔离为不同的线程池，如用户服务线程池、推荐服务线程池和积分服务线程池。从而避免某个服务的出现问题导致整个服务不可用。Java除了线程池隔离，也有基于信号量的做法。

  

  

+ 

