### 微服务可用性设计

+ 隔离
+ 超时控制
+ 过载保护
+ 限流
+ 降级
+ 重试
+ 负载均衡
+ 最佳实践



### 隔离

隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。

1. **服务隔离**
   + 动静分离、读写分离
2. **轻重隔离**
   + 核心、热点、快慢
3. **物理隔离**
   + 线程、进程、集群、机房



#### 服务隔离

+ 动静隔离

  本质上是加速/缓存访问变换频次小的。例如，CPU的`cacheline` false sharing；数据库mysql表设计中避免buffpool频繁过期；隔离动静表；架构中的图片、静态资源等缓存加速。

  

  在CDN场景中，将静态资源和动态API分离，也是体现了隔离的思路。

  - 降低应用服务器负载，静态文件访问负载全部通过CDN。
  - 静态CDN宽带加速，延迟低。
  - 对象存储存储费用低。
  - 海量存储空间，无需考虑存储架构升级。

  在数据库场景中，MySQL BufferPool是用于缓存DataPage的，DataPage可以理解为缓存了表的行。那么如果频繁更新数据表，导致DataPage不断置换，从而导致命中率下降的问题。

  在表设计中，可以沿用类似的思路，其主表很少更新，而旁路表或统计表需要高频更新。此时可以对主表和旁路表进行分离分库，从而使得主表合理利用DataPage的缓存。而高频更新的数据可以订阅某些事件的数据(例如`binlog`)实现对数据的更新。

+ 读写分离：主从、`ReplicaSet`、`CQRS`(Command Query Responsibility Segregation, 命令查询的责任分离)。

#### 轻重隔离

+ 核心隔离

  业务按照Level进行资源池划分(L0/L1/Le)。

  - 核心/非核心的故障域的差异隔离(机器资源是否独占、依赖资源)。
  - 多集群，通过冗余资源来提升吞吐和容灾能力。

+ 快慢隔离

  服务的吞吐想象为一个池子，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增加，对小请求产生影响。

+ 

