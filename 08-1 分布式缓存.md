### 分布式缓存

+ 缓存选型
+ 缓存模式
+ 缓存技巧

#### 缓存选型

**memcache**

memcache 提供简单的kv cache存储，value大小不超过1mb。

memcache 作为大文本或者简单的kv结构使用。 使用了slab(分块)方式做内存管理，存在一定的浪费，如果大量接近的item，建议调整memcache参数来优化每一个slab增长的ratio、可以通过设置slab_automove和slab_reassign开启memcache的动态/手动move slab，防止某些slab热点导致内存足够的情况下引发LRU。

大部分情况下，简单KV推荐使用memcache，吞吐和响应都足够好。



![image](https://github.com/lecc2cc/microgo/blob/master/images/08-mem-2021-06-07-23.png?raw=true)

每个slab包含若干大小为1M的内存页，这些内存又被分割成多个chunk，每个chunk存储一个item；

在memcache启动初始化时，每个slab都预分配一个1M的内存页，由slabs——preallocate完成。chunk的增长因子由-f指定，默认1.25，起始大小为48字节。



**redis**



redis有丰富的数据类型，支持增量方式的修改部分数据，比如排行榜，集合，数组等。

redis因为没有使用内存池，所以是存在一定的内存碎片，一般使用jemalloc来优化内存分配，需要编译时使用jemalloc库替代glib的malloc使用。



redis和memcache最大的区别其实是redis单线程(新版本双线程)、memcache多线程，所以QPS可能两者差异不大，但是吞吐会有很大的差别，比如大数据value返回的时候，redis qps会抖动下降的很厉害。



建议纯kv都走memcache，复杂数据类型使用redis。可以使用memcache+redis双缓存设计。



**Proxy**

+ twemproxy

  单进程单线程模型和redis类似，在处理一些大key的时候可能出现IO瓶颈； 二次开发成本难度高，难以与公司运维平台进行深度集成； 不支持自动伸缩，不支持autorebalance，增删结点需要重启才能生效； 运维不友好，没有控制面板；

+ codis

  只支持redis协议，且需要使用patch版本的redis

+ mcrouter

  只支持memcache协议，C开发，运维集成成本难度高。

可以使用最新版的redis cluster。













