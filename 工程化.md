### 工程化



#### 项目目录结构



参考：[golang-standards/project-layout](https://github.com/golang-standards/project-layout)

```
|-- cmd
|   |__ myapp
|   |   |__ main.go
|   |
|   |__ myapp1
|       |__ main.go
|
|-- internal
|   |__ myapp
|   |   |__ biz
|   |   |__ data
|   |   |__ service
|   |   |__ ..
|   |
|   |__ pkg
|       |__ ...
|
|   
|-- pkg
|   |__ cache
|   |    |__ memcache
|   |    |__ redis
|   |
|   |__ conf
|   |    |__ dsn
|   |    |__ env
|   |    |__ flagvar
|   |
|   |__ ...
|
|-- docs
|-- examples
|-- third_party
|-- tools
|-- ...
```

##### Go 目录

+ `/cmd`

  项目的入口。每个应用程序的目录名应该与构建的可执行文件的名称相匹配。例如，构建一个`myapp`可执行二进制文件对应的目为`/cmd/myapp`。

​				通常不要在这个目录中放置太多的代码。只应包含程序启动的初始化代码即可。如果认为代码可以导入并在其他项目中使用，那么它应该位于`/pkg`目录中。或者不希望其他人重用它，或代码不是可重用的，应将该代码放到`internal`目录中。

+ `internal`

  私有应用程序和库代码。这些代码不应该或不希望其他人在其应用程序或库中导入。

​				在项目的任何目录下都可以有`internal`目录，而不仅仅局限于顶级`internel`目录。`internal`目录可以添加任何的子目录，用于分隔内部代码中的共享和非共享代码。例如，存在多个实际应用程序时，各个应用程序的代码可以放在`/internal/app`目录下（例如，`/internal/app/myapp`）；这些应该程序共享的代码可以放在`/internal/pkg`目录下（例如，`/internal/pkg/myprivlib`）。

+ `/pkg`

  外部应用程序可以使用的库代码。其他项目会导入这些库，所在在这里放东西之前要考虑清楚。



​				`/pkg`目录内，可以参考go标准库的组织方式，按照功能分类。`/internal/pkg`一般用于项目内的跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。				

##### 服务应用程序目录

+ ### `/api`

  OpenAPI/Swagger 规范，JSON 模式文件，协议定义文件。

+ 

##### 其他目录

​	当根目录包含大量非Go组件和目录，这也是一种将Go代码分组到一个位置的方法，这使得运行各种Go工具变得更加容易组织。

+ `/docs`

  设计和用户文档(除了 godoc 生成的文档之外)。

+ `/examples`

  你的应用程序和/或公共库的示例。

+ `/third_party`

  外部辅助工具，分叉代码和其他第三方工具(例如 Swagger UI)。

+ `/tools`

  这个项目的支持工具。注意，这些工具可以从 `/pkg` 和 `/internal` 目录导入代码。

+ `/build`

  打包和持续集成。

​				将你的 CI (travis、circle、drone)配置和脚本放在 `/build/ci` 目录中。

+ `/deployments`

  IaaS、PaaS、系统和容器编排部署配置和模板(docker-compose、kubernetes/helm、mesos、terraform、bosh)。注意，在一些存储库中(特别是使用 kubernetes 部署的应用程序)，这个目录被称为 `/deploy`。

+ `/test`

  额外的外部测试应用程序和测试数据。你可以随时根据需求构造 `/test` 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 `/test/data` 或 `/test/testdata` (如果你需要忽略目录中的内容)。



#### Kit Project Layout

`kit project`又称基础库/框架，是独立于具体应用项目的项目。

kit项目必须具备的特点：

+ 统一
+ 标准库方式布局
+ 高度抽象
+ 支持插件

#### Service Application Project Layout

服务应用的项目结构

```
.
|-- README.md
|-- api
|-- cmd
|-- configs
|-- internel
|-- test
|-- go.mod
|-- go.sum
|__ ...
```

**不应该包含: /src目录**

+ `/cmd` 

  应用目录，与二进制执行文件同名划分子目录。cmd应用目录只应负责应用程序的生命周期管理，即程序的启动，关闭，配置初始化等。

+ `/api` 

  API协议定义目录，例如 protobuf文件以及生产的go文件。

+ `/configs`

  配置文件模板或默认配置。

+ `/test`

  额外的外部测试应用程序和测试数据。



一个gitlab的project里面可以放置多个微服务的app。也可以按照gitlab的group里面建立多个project，每个project对应一个app。

```
|
|-- app
|    |-- account
|    |    |__ cmd
|    |    |    |__ myapp1-admin
|    |    |    |__ myapp1-interface
|    |    |    |__ myapp1-job
|    |    |    |__ myapp1-service
|    |    |    |__ myapp1-task
|    |    |__ api
|    |    |__ ..
|    |    
|    |-- member
|    |__ ...
|
|-- pkg
|    |-- database
|    |-- log
|    |__ ..
|
|__ ...
```



一个gitlab的project放置多个app时：

+ app目录内的每个微服务按照自己的全局唯一名称来建立目录。比如`"account.service.vip"`，对应目录"`account/vip/*`"。
+ 和app平级的目录`pkg`存放相关业务的公共库(非基础框架库)。如果应用不希望导出这些目录，可以放置在实际app目录下的`internal`目录，比如`account/internal/pkg/`。

微服务中的app服务类型分为5类：`interface` 、`service` 、`job` 、`admin` 和 `task`。

+ `interface`: 对外的BFF服务，接受来自用户的请求，比如对外暴露的HTTP/gRPC接口。
+ `service`: 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了gRPC接口只对内服务。
+ `admin`: 区别于`service`，更多是面向运营侧的服务，通常数据权限更高，隔离带来更好的代码级别安全。
+ `job`: 流式任务的服务，上游一般依赖message broker，偏向异步的流程。
+ `task`: 定时任务，类似`crontab`，部署到task托管平台中。

